package tutorials.doobie

import cats.implicits.*
import cats.effect.*
import doobie.*
import doobie.implicits.*
import doobie.util.transactor.Transactor
import doobie.util.update.Update
import doobie.util.Get
import doobie.util.Put
import doobie.util.Read
import doobie.util.Write
import doobie.syntax.ConnectionIOOps
import java.util.UUID

object DoobieDemo extends IOApp:

  case class Actor(id: Int, name: String)
  case class Movie(id: UUID, title: String, year: Int, actors: List[String], director: String)

  extension [A](io: IO[A])
    def debug: IO[A] = io.map { a =>
      println(s"[${Thread.currentThread.getName}] $a")
      a
    }

  val xa: Transactor[IO] = Transactor
    .fromDriverManager[IO](
      "org.postgresql.Driver",
      "jdbc:postgresql://localhost:5432/myimdb",
      "docker",
      "docker"
    )

  def findAllActorNames: IO[List[String]] =
    sql"select name from actors"
      .query[String]
      .to[List]
      .transact(xa)

  def streamAllActorNames: fs2.Stream[IO, String] =
    sql"select name from actors"
      .query[String]
      .stream // it's possible to convert the stream to a list by calling '.compile.toList' here
      .transact(xa)

  def findActorById(id: String): IO[Actor] =
    sql"select id, name from actors where id = $id"
      .query[Actor]
      .unique
      .transact(xa)

  def findActorByName(name: String): IO[Option[Actor]] =
    sql"select id, name from actors where name = $name"
      .query[Actor]
      .option
      .transact(xa)

  def findActorByName2(name: String): IO[Option[Actor]] =
    HC.stream[Actor](
      "select id, name from actors where name = ?",
      HPS.set(name),
      100
    ).compile
      .toList
      .map(_.headOption)
      .transact(xa)

  def findActorsByInitialLetter(ch: Char): IO[List[Actor]] =
    val select    = fr"select id, name"
    val from      = fr"from actors"
    val where     = fr"where LEFT(name, 1) = ${ch.toString}"
    val statement = select ++ from ++ where
    statement
      .query[Actor]
      .stream
      .compile
      .toList
      .transact(xa)

  def saveActor(id: Int, name: String): IO[Int] =
    sql"insert into actors (id, name) values ($id, $name)" //
      .update                                              //
      .run
      .transact(xa)

  def saveActor(actor: Actor): IO[Int] =
    Update[Actor]("insert into actors (id, name) values (?, ?)")
      .run(actor)
      .transact(xa)

  def saveActorAutoGenerated(name: String): IO[Int] =
    sql"insert into actors (name) values ($name)" //
      .update
      .withUniqueGeneratedKeys[Int]("id")
      .transact(xa)

  def saveActors(names: List[String]): IO[List[Actor]] =
    Update[String]("insert into actors (name) values (?)")
      .updateManyWithGeneratedKeys[Actor]("id", "name")(names)
      .compile
      .toList
      .transact(xa)

  /** type classes for doobie
    */

  case class ActorName(name: String)

  object ActorName:
    given G: Get[ActorName] = Get[String].map(ActorName.apply)
    given P: Put[ActorName] = Put[String].contramap(_.name)

  def findAllActorNamesCustomClass: IO[List[ActorName]] =
    sql"select name from actors"
      .query[ActorName]
      .to[List]
      .transact(xa)

  // value classes
  case class DirectorId(id: Long)
  case class DirectorName(name: String)
  case class DirectorLastname(lastname: String)
  case class Director(id: DirectorId, name: DirectorName, lastname: DirectorLastname)

  object Director:
    given R: Read[Director]  =
      Read[(Long, String, String)].map { case (id, name, lastname) =>
        Director(DirectorId(id), DirectorName(name), DirectorLastname(lastname))
      }
    given W: Write[Director] =
      Write[(Long, String, String)].contramap {
        case Director(DirectorId(id), DirectorName(name), DirectorLastname(lastname)) =>
          (id, name, lastname)
      }

  // necessary imports so that we don't have to write an Get[Movie] instance

  import doobie.postgres.*
  import doobie.postgres.implicits.*

  // write large queries
  def findMovieByTitle(title: String): IO[Option[Movie]] =
    sql"""
      | select m.id, m.title, m.year_of_production, array_agg(a.name) as actors, d.name || ' ' || d.last_name
      | from movies m
      | join movies_actors ma on m.id = ma.movie_id
      | join actors a on ma.actor_id = a.id
      | join directors d on m.director_id = d.id
      | where m.title = $title
      | group by (m.id, m.title, m.year_of_product, d.name, d.last_name)
    """.stripMargin
      .query[Movie]
      .option
      .transact(xa)

  def findMovieByTitle_v2(title: String): IO[Option[Movie]] =
    def findMovieByTitle =
      sql"select id, title, year_of_production from movies where title = $title"
        .query[(UUID, String, Int, Int)]
        .option

    def findDirectorById(directorId: Long) =
      sql"select name, last_name from directors where id = $directorId"
        .query[(String, String)]
        .option

    def findActorsByMovieId(movieId: UUID) =
      sql"""
         | select a.name from actors a
         | join movies_actors ma on a.id = ma.actor_id
         | where ma.movie_id = $movieId
      """.stripMargin
        .query[String]
        .to[List]

    val query = for
      maybeMovie    <- findMovieByTitle
      maybeDirector <- maybeMovie match
                         case Some((_, _, _, directorId)) => findDirectorById(directorId)
                         case None                        => Option.empty[(String, String)].pure[ConnectionIO]
      actors        <- maybeMovie match
                         case Some((movieId, _, _, _)) => findActorsByMovieId(movieId)
                         case None                     => List.empty[String].pure[ConnectionIO]
    yield for
      (id, title, year, _)  <- maybeMovie
      (firstname, lastname) <- maybeDirector
    yield Movie(id, title, year, actors, s"$firstname $lastname")

    query.transact(xa)

  override def run(args: List[String]): IO[ExitCode] =
    IO(println("Hello, doobie")).as(ExitCode.Success)
